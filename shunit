#! /usr/bin/env bash
test_folder=$1
target_folder="$(pwd)/test-reports"
[[ -d "$target_folder" ]] && rm -rf "$target_folder"
mkdir -p "$target_folder"
test_logfile="$target_folder/test.log"
xml_output_file="$target_folder/test.xml"
touch "$test_logfile"
exec 3>&1

####################
#### Statistics ####
####################

OPEN='open'
CLOSE='close'
BEGIN='begin'
END='end'
ASSERT='assert'
ERROR='error'
TEST='test'
FILE='file'
SUMMARY='summary'

function log_event() {
  local event_type=$1
  local event_data=$2
  local event="${event_type}|${event_data}|$(date +'%s')"
  echo -e "${event}" >> "$test_logfile"

  case $event_type in
    $OPEN)
      present_to_user "${event}"
      ;;
    $TEST)
      present_to_user "${event}"
      present_latest_problems
      ;;
    $FILE)
      present_to_user "${event}"
      present_to_user ""
      ;;
    $SUMMARY)
      present_to_user "${event}"
      ;;
  esac

}

function present_to_user() {
  local green=$(echo -e '\e[32m')
  local red=$(echo -e '\e[31m')
  local reset=$(echo -e '\e[39m')
  echo "${1}" | sed \
    -e "s/^$OPEN|\(.*\)|.*/  \1:/" \
    -e "s/^$TEST|\(.*\)|s|.*/$green    +$reset \1/" \
    -e "s/^$TEST|\(.*\)|.*|.*|.*/$red    -$reset \1/" \
    -e "s/^$ASSERT|f|\(.*\)|\(.*\)|.*/$red      [Failure]$reset line \2: \1/" \
    -e "s/^$ERROR|\(.*\)|.*|.*/$red      [Error]$reset \1/" \
    -e "s/^$FILE|.*|\(.*\)|\(.*\)|\(.*\)|\(.*\)|.*/  [Sum] tests: \1 failures: \2 errors: \3 time: \4s/" \
    -e "s/^$SUMMARY|\(.*\)|\(.*\)|\(.*\)|\(.*\)|.*/[Total] tests: \1 failures: \2 errors: \3 time: \4s/" \
    -e "/^$ASSERT|s|/d" >&3
}

function present_latest_problems() { # I don't really like this :/
  local problems=$(sed '1!G;h;$!d' "$test_logfile" | sed -e "/^$BEGIN|/,\$d" | grep -E "(^$ERROR|^$ASSERT)")
  present_to_user "${problems}"
}

function generate_junit_xml() {
{ sed '1!G;h;$!d' test-reports/test.log | grep -E "(^$ASSERT|^$ERROR|^$TEST|^$FILE|^$SUMMARY|^$BEGIN|^$OPEN)" | sed \
    -e "/^$ASSERT|s|/d" \
    -e "s/^$SUMMARY|\(.*\)|\(.*\)|\(.*\)|\(.*\)|.*/<testsuites tests='\1' failures='\2' errors='\3' time='\4'>/" \
    -e "s/^$FILE|\(.*\)|\(.*\)|\(.*\)|\(.*\)|\(.*\)|.*/<testsuite name='\1' tests='\2' failures='\3' errors='\4' time='\5'>/" \
    -e "s/^$ASSERT|f|\(.*\)|.*|.*/<failure message='Assertion failed' type='failure'>\1<\/failure>/" \
    -e "s/^$ERROR|\(.*\)|.*|.*/<error message='Error' type='error'>\1<\/error>/" \
    -e "s/^$TEST|\(.*\)|.*|\(.*\)|.*/<testcase name='\1' time='\2'>/" \
    -e "s/^$BEGIN|.*/<\/testcase>/" \
    -e "s/^$OPEN|.*/<\/testsuite>/"; echo "</testsuites>"; } | xmllint --format - > "$xml_output_file"
}

function summarize_test() {
  test_name=$1
  test_data=$(awk '/^'"$BEGIN"'\|'"$test_name"'\|/,/^'"$END"'\|'"$test_name"'/' "$test_logfile")
  failures=$(grep -c "^$ASSERT|f|" <(echo "$test_data"))
  errors=$(grep -c "^$ERROR" <(echo "$test_data"))
  seconds=$(cut -d '|' -f 3  <(echo "$test_data") | sed -e 1b -e '$!d' | sort -nr | paste -sd- - | bc)

  if [[ "$errors" -gt 0 ]]; then
    status='e'
  elif [[ "$failures" -gt 0 ]]; then
    status='f'
  else
    status='s'
  fi

  log_event "$TEST" "${test_name}|${status}|${seconds}"
}

function summarize_file() {
  file_name=${1//\//\\/}
  file_data=$(awk '/^'"$OPEN"'\|'"$file_name"'\|/,/^'"$CLOSE"'\|'"$file_name"'/' "$test_logfile" | grep "^$TEST")
  # todo apply some more awk foo here
  stats=$(grep "^$TEST" <(echo "$file_data") | cut -d '|' -f 3 | sort | uniq -c)
  tests=$(grep -c "^$TEST" <(echo "$file_data"))
  failures=$(sed -n 's/   \(.*\) f/\1/p' <(echo "$stats"))
  errors=$(sed -n 's/   \(.*\) e/\1/p' <(echo "$stats"))
  seconds=$(awk -F '|' '{sum+=$4} END {print sum}' <(echo "$file_data"))

  log_event "$FILE" "${1}|${tests:-0}|${failures:-0}|${errors:-0}|${seconds}"
}

function summarize() {
  # todo apply some more awk foo here
  sum_data=$(grep "^$FILE" "$test_logfile")
  tests=$(awk -F '|' '{sum+=$3} END {print sum}' <(echo "$sum_data"))
  failures=$(awk -F '|' '{sum+=$4} END {print sum}' <(echo "$sum_data"))
  errors=$(awk -F '|' '{sum+=$5} END {print sum}' <(echo "$sum_data"))
  seconds=$(awk -F '|' '{sum+=$6} END {print sum}' <(echo "$sum_data"))

  log_event "$SUMMARY" "${tests}|${failures}|${errors}|${seconds}"
}

#################
#### Asserts ####
#################

function assert_equals() { # assert that $1 is equal to $2
  local called_by_line="${BASH_LINENO[0]}"
  if [[ "$1" -eq "$2" ]]; then
    log_event "$ASSERT" "s|Success|$called_by_line"
  else
    log_event "$ASSERT" "f|Expected $1 but got $2|$called_by_line"
  fi
}

function assert_none_empty() { # assert that $1 is not empty or only spaces
  local called_by_line="${BASH_LINENO[0]}"
  if [[ -n "${1// }" ]]; then
    log_event "$ASSERT" "s|Success|$called_by_line"
  else
    log_event "$ASSERT" "f|Value was empty, when expecting nonEmpty|$called_by_line"
  fi
}


function assert_is_substring_of() { # assert that $1 is a substring of $2
  local called_by_line="${BASH_LINENO[0]}"
  if [[ "$2" =~ $1 ]]; then
    log_event "$ASSERT" "s|Success|$called_by_line"
  else
    log_event "$ASSERT" "f|'$1' was not a substring of '$2'|$called_by_line"
 fi
}

######################
#### Test Running ####
######################

function execute_function() {
    output=$($1 2>&1)
    status=$?

    if [[ "$status" -gt 0 ]]; then
      message=$(echo "$output" | sed 's/.*: \(line .*\)/\1/')
      log_event "$ERROR" "${message}|${status}"
    fi
}

function check_file() {
  # todo sanitycheck the file
  local test_file=$1
  . "$test_file"

  log_event "$OPEN" "$test_file"

  # Run setup function if defined
  grep -q '^function setup()' "$test_file" && execute_function "setup"

  sed -n 's/^function \(check_.*\)().*/\1/p' "$test_file" | while IFS= read -r test_name; do
    log_event "$BEGIN" "$test_name"
    execute_function "$test_name"
    log_event "$END" "$test_name"
    summarize_test "$test_name"
  done

  # Run cleanup if defined
  grep -q '^function cleanup()' "$test_file" && execute_function "cleanup"

  log_event "$CLOSE" "$test_file"
  summarize_file "$test_file"
}

function run_tests() {
  # generate a summary
  # create a rapport
  while IFS= read -r -d '' file; do
    (check_file "$file")
  done < <(find "$test_folder" -type f \( -name '*.bash' -or -name '*.sh' \) -print0)
  summarize
  generate_junit_xml
}

#######################
#### Main handling ####
#######################

run_tests
